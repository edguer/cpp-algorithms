These social network connections are better handled with graphs. Luckily, nowadays we have many Graph Database options, such as Cosmos Db or Neo4j. Example: each "thing" is a node, such as person, post or company, and each edge can represent a type of connection, such as "likes", "friendship" etc. (usually an edge gives the distance between two nodes, but here it can be adapted to those different connection types). Getting the path between two people can be done typical traversal algorithms. If we don't care about getting the shortest path, we can simply use DFS and, which will be faster in this case, since it will find the first path and return right away. Doing BFS would be good if we want to find the shortest path, but it may come with a cost of trying every single path to that person. 
In fact: BFS is more effective, since a friend should be only one or two levels away, and by doing DFS one will actually traverse thousands of millions of users in a single tree leaf. Not a good idea. With BFS, you will find your friend with a handful of cycles.

Implementing the graph database is not an easy task. If we are talking about millions of people, the first and most intuitive approach would be having the graph sharded in disk accross the globe and apply some localized data affinity rule (brazilian profiles, pages etc. stays hosted in brazilian servers), which diminishes latency. In each region, the data could be sharded between many servers, in an evenly distributed manner. Cache is important, so keeping some really short TTL for the most accessed content will help - it will leave the cache soon if it stops being a trend. It may be worthwhile to replicate some nodes and edges from other countries in a region, since it reduces round-trips and latency. It could be done on a per-usage basis, like a lazy cache, or by having a "hot list" of pages and personnalities that are known more broadly. 
There is the challenge of knowing when to reach another region whenever we hit the boundaries of the graph. Example: suppose Eduardo has a connection with Michael, an american. As Michael is a US user, the system should know that it has to fetch more data related to data user in another region.
The graph can even be clustered in machines according to geography, or "social intensity", meaning putting people that are closer to one another in the graph on the same machine. If a lot of jumps to other machines are required, batching will be a good alternative: traverse the in-machine graph first and store the list of people data should be fetched in other machines and regions, and do it in chunks.