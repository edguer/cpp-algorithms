As N is no greater than 32,000, one could use an unsigned short int (2 bytes) for each number. We don't know the total size of the array, since there might duplicates, meaning that if N is 32k, its total size could be greater than 32k. One solution would be creating a bit array of 32k bits, total size of 4kb. We start iterating the numbers one by one and marking the bit corresponding to that number on the bit array (by shifting one and using or: array |= 1 << number) and, if (array & (1 << number)) != 0, then the number is duplicated and I can print it. Total memory cost, aside the array itself, will be: 4kb for the bit array, time complexity if O(N). 
For lower memory consumption, one case use the ranges strategy, in which you calculate the number of occurences on ranges, for example from 1-1000, 1001-2000 and so on. At the end, if a range has more than 999 ocurrences, we iterate the number again, this time only caring about that specific range and storing the duplicates on a boolean array or a bit array of size 999. The problem with this approach is the time complexity: it would be O(2n), but it would consume: 64bytes for the range arrays and 125 bytes for the bit array.